/**
 * Payroll Finance Service
 * 
 * Bordro kaydetme ve Finance modülü entegrasyonu servisi.
 * Bordro hesaplamalarını veritabanına kaydeder ve muhasebe kayıtları oluşturur.
 */

import { supabase } from "@/integrations/supabase/client";
import type { PayrollCalculationResult } from "./payrollService";

export interface PayrollItemData {
  employee_id: string;
  base_salary: number;
  gross_salary: number;
  overtime_pay: number;
  bonus_premium: number;
  sgk_base: number;
  sgk_employee_share: number;
  sgk_employer_share: number;
  unemployment_employee: number;
  unemployment_employer: number;
  accident_insurance: number;
  income_tax_base: number;
  income_tax_amount: number;
  income_tax_exemption: number;
  stamp_tax_amount: number;
  stamp_tax_exemption: number;
  total_deductions: number;
  net_salary: number;
  total_employer_cost: number;
  allowances_total: number;
  advances_total: number;
  garnishments: number;
  is_minimum_wage_exemption_applied: boolean;
  warnings: string[];
}

export interface SavePayrollRunOptions {
  companyId: string;
  year: number;
  month: number;
  employeeCalculations: Array<{
    employeeId: string;
    calculation: PayrollCalculationResult;
  }>;
  autoGenerated?: boolean;
  userId?: string;
}

export interface PayrollFinanceEntryData {
  payroll_item_id: string;
  payroll_run_id: string;
  company_id: string;
  employee_id: string;
  gross_salary_expense: number;
  sgk_employee_deduction: number;
  sgk_employer_expense: number;
  unemployment_employee_deduction: number;
  unemployment_employer_expense: number;
  accident_insurance_expense: number;
  income_tax_deduction: number;
  stamp_tax_deduction: number;
  net_salary_payable: number;
  total_employer_cost: number;
  transaction_date: string;
  payment_status: 'pending' | 'paid' | 'cancelled';
  created_by?: string;
}

/**
 * Bordro run ve itemları kaydet
 * payroll_runs ve payroll_items tablolarına veri ekler
 */
export async function savePayrollRun(options: SavePayrollRunOptions) {
  const { companyId, year, month, employeeCalculations, autoGenerated = false, userId } = options;

  try {
    // 1. Mevcut payroll_run kontrolü (aynı dönem için)
    const { data: existingRun, error: checkError } = await supabase
      .from('payroll_runs')
      .select('id, status')
      .eq('company_id', companyId)
      .eq('payroll_period_year', year)
      .eq('payroll_period_month', month)
      .maybeSingle();

    if (checkError) {
      console.error('Payroll run check error:', checkError);
      throw new Error(`Mevcut bordro kontrolü başarısız: ${checkError.message}`);
    }

    let payrollRunId: string;

    if (existingRun) {
      // Eğer varsa ve status = 'approved' ise hata ver
      if (existingRun.status === 'approved' || existingRun.status === 'locked') {
        throw new Error(`${year}/${month} dönemi için zaten onaylanmış bir bordro var. Önce onayı kaldırın.`);
      }
      
      // Varolan run'ı kullan
      payrollRunId = existingRun.id;
      console.log(`✓ Mevcut payroll_run kullanılıyor: ${payrollRunId}`);
      
      // Eski itemları sil
      const { error: deleteError } = await supabase
        .from('payroll_items')
        .delete()
        .eq('payroll_run_id', payrollRunId);
      
      if (deleteError) {
        console.error('Old items delete error:', deleteError);
        throw new Error(`Eski bordro kayıtları silinemedi: ${deleteError.message}`);
      }
    } else {
      // 2. Yeni payroll_run oluştur
      const { data: newRun, error: runError } = await supabase
        .from('payroll_runs')
        .insert({
          company_id: companyId,
          payroll_period_year: year,
          payroll_period_month: month,
          status: 'draft',
          auto_generated: autoGenerated,
          approval_status: 'pending',
          finance_sync_status: 'pending',
          created_by: userId,
        })
        .select('id')
        .single();

      if (runError || !newRun) {
        console.error('Payroll run insert error:', runError);
        throw new Error(`Bordro run oluşturulamadı: ${runError?.message || 'Bilinmeyen hata'}`);
      }

      payrollRunId = newRun.id;
      console.log(`✓ Yeni payroll_run oluşturuldu: ${payrollRunId}`);
    }

    // 3. Payroll items oluştur
    const payrollItems: PayrollItemData[] = employeeCalculations.map(({ employeeId, calculation }) => ({
      employee_id: employeeId,
      base_salary: calculation.base_salary,
      gross_salary: calculation.gross_salary,
      overtime_pay: calculation.overtime_pay,
      bonus_premium: calculation.bonus_premium,
      sgk_base: calculation.sgk_base,
      sgk_employee_share: calculation.sgk_employee_share,
      sgk_employer_share: calculation.sgk_employer_share,
      unemployment_employee: calculation.unemployment_employee,
      unemployment_employer: calculation.unemployment_employer,
      accident_insurance: calculation.accident_insurance,
      income_tax_base: calculation.income_tax_base,
      income_tax_amount: calculation.income_tax_amount,
      income_tax_exemption: calculation.income_tax_exemption,
      stamp_tax_amount: calculation.stamp_tax_amount,
      stamp_tax_exemption: calculation.stamp_tax_exemption,
      total_deductions: calculation.total_deductions,
      net_salary: calculation.net_salary,
      total_employer_cost: calculation.total_employer_cost,
      allowances_total: calculation.allowances_total || 0,
      advances_total: calculation.advances_total || 0,
      garnishments: calculation.garnishments || 0,
      is_minimum_wage_exemption_applied: calculation.is_minimum_wage_exemption_applied,
      warnings: calculation.warnings || [],
    }));

    const itemsToInsert = payrollItems.map(item => ({
      ...item,
      payroll_run_id: payrollRunId,
      company_id: companyId,
      created_by: userId,
    }));

    const { data: insertedItems, error: itemsError } = await supabase
      .from('payroll_items')
      .insert(itemsToInsert)
      .select('id, employee_id');

    if (itemsError || !insertedItems) {
      console.error('Payroll items insert error:', itemsError);
      throw new Error(`Bordro kalemleri kaydedilemedi: ${itemsError?.message || 'Bilinmeyen hata'}`);
    }

    console.log(`✓ ${insertedItems.length} payroll_item kaydedildi`);

    // 4. Bordro run'ı calculated durumuna güncelle
    const { error: updateError } = await supabase
      .from('payroll_runs')
      .update({
        status: 'calculated',
        calculated_at: new Date().toISOString(),
        calculated_by: userId,
      })
      .eq('id', payrollRunId);

    if (updateError) {
      console.error('Payroll run status update error:', updateError);
      // Bu critical değil, devam edebiliriz
    }

    return {
      success: true,
      payrollRunId,
      itemCount: insertedItems.length,
    };
  } catch (error: any) {
    console.error('❌ savePayrollRun error:', error);
    throw error;
  }
}

/**
 * Bordro Finance entegrasyonu
 * payroll_items'dan payroll_finance_entries oluşturur
 */
export async function syncPayrollToFinance(payrollRunId: string, userId?: string) {
  try {
    // 1. Payroll run bilgilerini al
    const { data: payrollRun, error: runError } = await supabase
      .from('payroll_runs')
      .select('*, company_id, payroll_period_year, payroll_period_month')
      .eq('id', payrollRunId)
      .single();

    if (runError || !payrollRun) {
      throw new Error(`Bordro run bulunamadı: ${runError?.message || 'Bilinmeyen hata'}`);
    }

    // Zaten sync edilmişse hata ver
    if (payrollRun.finance_sync_status === 'synced') {
      throw new Error('Bu bordro zaten Finance modülüne senkronize edilmiş');
    }

    // 2. Payroll items'ları al
    const { data: payrollItems, error: itemsError } = await supabase
      .from('payroll_items')
      .select('*')
      .eq('payroll_run_id', payrollRunId);

    if (itemsError || !payrollItems || payrollItems.length === 0) {
      throw new Error(`Bordro kalemleri bulunamadı: ${itemsError?.message || 'Bilinmeyen hata'}`);
    }

    console.log(`✓ ${payrollItems.length} payroll_item Finance'e aktarılacak`);

    // 3. Finance entries oluştur
    const transactionDate = `${payrollRun.payroll_period_year}-${String(payrollRun.payroll_period_month).padStart(2, '0')}-${new Date().getDate()}`;

    const financeEntries: Omit<PayrollFinanceEntryData, 'payroll_item_id'>[] = payrollItems.map((item: any) => ({
      payroll_run_id: payrollRunId,
      company_id: payrollRun.company_id,
      employee_id: item.employee_id,
      gross_salary_expense: item.gross_salary,
      sgk_employee_deduction: item.sgk_employee_share,
      sgk_employer_expense: item.sgk_employer_share,
      unemployment_employee_deduction: item.unemployment_employee,
      unemployment_employer_expense: item.unemployment_employer,
      accident_insurance_expense: item.accident_insurance,
      income_tax_deduction: item.income_tax_amount,
      stamp_tax_deduction: item.stamp_tax_amount,
      net_salary_payable: item.net_salary,
      total_employer_cost: item.total_employer_cost,
      transaction_date: transactionDate,
      payment_status: 'pending' as const,
      created_by: userId,
    }));

    const entriesToInsert = financeEntries.map((entry, index) => ({
      ...entry,
      payroll_item_id: payrollItems[index].id,
    }));

    const { data: insertedEntries, error: entriesError } = await supabase
      .from('payroll_finance_entries')
      .insert(entriesToInsert)
      .select('id');

    if (entriesError || !insertedEntries) {
      console.error('Finance entries insert error:', entriesError);
      
      // Sync status'u failed yap
      await supabase
        .from('payroll_runs')
        .update({ finance_sync_status: 'failed' })
        .eq('id', payrollRunId);
      
      throw new Error(`Finance kayıtları oluşturulamadı: ${entriesError?.message || 'Bilinmeyen hata'}`);
    }

    console.log(`✓ ${insertedEntries.length} finance entry oluşturuldu`);

    // 4. Payroll run'ın sync durumunu güncelle
    const { error: updateError } = await supabase
      .from('payroll_runs')
      .update({
        finance_sync_status: 'synced',
        finance_synced_at: new Date().toISOString(),
      })
      .eq('id', payrollRunId);

    if (updateError) {
      console.error('Payroll run finance sync status update error:', updateError);
      // Bu critical değil ama logla
    }

    return {
      success: true,
      entriesCount: insertedEntries.length,
    };
  } catch (error: any) {
    console.error('❌ syncPayrollToFinance error:', error);
    throw error;
  }
}

/**
 * Bordro run onaylama
 */
export async function approvePayrollRun(
  payrollRunId: string,
  approverId: string,
  approved: boolean = true,
  rejectionReason?: string
) {
  try {
    const { data, error } = await supabase.rpc('approve_payroll_run', {
      p_payroll_run_id: payrollRunId,
      p_approver_id: approverId,
      p_approved: approved,
      p_rejection_reason: rejectionReason || null,
    });

    if (error) {
      throw new Error(`Onay işlemi başarısız: ${error.message}`);
    }

    // Onaylanmışsa Finance sync'i de tetikle
    if (approved) {
      await syncPayrollToFinance(payrollRunId, approverId);
    }

    return { success: true };
  } catch (error: any) {
    console.error('❌ approvePayrollRun error:', error);
    throw error;
  }
}

/**
 * Tekil çalışan bordrosu kaydetme (mevcut EmployeePayroll.tsx için)
 */
export async function saveSingleEmployeePayroll(
  companyId: string,
  employeeId: string,
  year: number,
  month: number,
  calculation: PayrollCalculationResult,
  userId?: string
) {
  return savePayrollRun({
    companyId,
    year,
    month,
    employeeCalculations: [{ employeeId, calculation }],
    autoGenerated: false,
    userId,
  });
}
